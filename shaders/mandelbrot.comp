#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16) in;
//layout(set = 0, binding = 0) image2D firstImage;
layout(rgba32f, set = 0, binding = 0) uniform image2D img_output;

/**
 *
 */
struct mandelbrot_param_t{
	ivec2 windowSize;
	vec2 pos;
	vec2 mousePos;
	float zoom;     /*  */
	float c;        /*  */
	int nrSamples;
};



layout(set = 0, binding = 1) uniform params{
	mandelbrot_param_t _params;
}u_pushConstants;

vec4 computeMandel(const ivec2 dim, const ivec2 coord) {

	const int samples = 100;
	const float lthreadhold = 2.0;

	vec2 uv = vec2(coord) / vec2(dim);
	//uv *= 0.5;
	const vec2 c = vec2(-.445, 0.0) +  vec2(uv - 0.5)* vec2(2.0+ 1.7*0.2  );
	vec2 complex = vec2(0,0);
	float n = 0;

   for(int i = 0; i < samples; i++){

	   complex = vec2(complex.x * complex.x - complex.y + complex.y, 2 * complex.x * complex.y) + c;

		/*  */
		if(dot(complex, complex) > lthreadhold * 2.0)
			break;
		n++;
	}


	float t = float(n) / float(samples);
	return vec4(t,t,t, 1.0);
	vec3 d = vec3(0.3, 0.3 ,0.5);
	vec3 e = vec3(-0.2, -0.3 ,-0.5);
	vec3 f = vec3(2.1, 2.0, 3.0);
	vec3 g = vec3(0.0, 0.1, 0.0);
	return vec4( d + e*cos( 6.28318*(f*t+g) ) ,1.0);
}

void main()
{

//   if(gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
//     return;

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = pixel_coords / ivec2(1280, 720);

	vec4 pixel = computeMandel(ivec2(1280, 720), pixel_coords);
	imageStore(img_output, pixel_coords, pixel);
}